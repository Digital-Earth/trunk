# if !defined(HEADERS__CELL)
	# define HEADERS__CELL

	# include "../../Core/Headers/modulo_7.h"

	/* A cell is represented as an array of at least 'Cell_iMinimumCount' chars.
	The Cell_tzc typedef is used to indicate a char array that represents a cell,
	having an internal structure unknown to clients.
	*/
	typedef char Cell_tzc;
	enum {Cell_iMinimumCount = 4};

	/* Performs some sanity checks on the cell and returns true if the cell is valid.
	This should be true for any cell generated by the API.
	*/
	Boolean_tb Cell_fbValid(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Constructs an array representing a root cell, as part of a cell variable declaration.
	Note that 'iuMaximumDirectionCount' must be a compile-time constant between 0 and CHAR_MAX,
	inclusively.
	*/
	# define Cell_mConstruct(Name, iuMaximumDirectionCount) \
		Name[Cell_iMinimumCount + (iuMaximumDirectionCount)] = {(iuMaximumDirectionCount), 0, 0, 0}

	/* Allocates a root cell with the specified maximum direction count, or returns null if unsuccessful. */
	Cell_tzc * Cell_fpzcAllocate(
		REGISTER char const cMaximumDirectionCount
	);

	/* Deallocates a cell that was allocated by "Cell_fpzcAllocate", setting the pointer to null. */
	void Cell_fDeallocate(
		REGISTER Cell_tzc * rpzcCell[mReferenceConst(1)]
	);

	/* Copies the cell.  Returns false if the copy could not be performed. */
	Boolean_tb Cell_fbCopy(
		REGISTER Cell_tzc rzcCell[mReferenceRestrictConst(Cell_iMinimumCount)],
		REGISTER Cell_tzc const rzcSource[mReferenceRestrictConst(Cell_iMinimumCount)]
	);

	/* Returns true if the cells are equivalent. */
	Boolean_tb Cell_fbEquivalent(
		REGISTER Cell_tzc const rzcLeftCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Cell_tzc const rzcRightCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Resets the cell to the root. */
	void Cell_fInitialize(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Appends to the cell from a string of ASCII directions.
	If the string does not represent a normalized cell, or there is insufficient capacity,
	pushes only the valid initial substring and returns false.
	*/
	Boolean_tb Cell_fbPushString(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER char const rzcString[mReference(1)]
	);

	/* Returns a string of ASCII directions that represents the cell. */
	char const * Cell_frzcAsString(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the maximum direction count of the cell. */
	char Cell_fcMaximumDirectionCount(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the direction count of the cell. */
	char Cell_fcDirectionCount(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the class for the given direction count, which equates
	to a modulo 7 sign (with zero for the root).
	*/
	Modulo7_teSign Cell_feClass(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the primary pentagonal vertex (pole) of the cell, or zero if none. */
	Modulo7_te Cell_fePrimaryVertex(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the secondary pentagonal vertex of the cell, or zero if none. */
	Modulo7_te Cell_feSecondaryVertex(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns the pentagonal vertex of the cell, within the polar tile.
	This is the secondary vertex if non-zero; otherwise, it is the primary vertex (or zero).
	Note that it is impossible for a non-zero secondary vertex to be the same
	direction as the primary vertex, allowing the vertex within the polar tile to be represented
	as a single direction.
	*/
	Modulo7_te Cell_feVertex(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns true if the cell is a hexagon. */
	Boolean_tb Cell_fbHexagon(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns true if the cell is a centroid. */
	Boolean_tb Cell_fbCentroid(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Returns true if the direction represents a normalized child of the cell. */
	Boolean_tb Cell_fbChild(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Modulo7_te const eDirection
	);

	/* Moves the cell to the child, or returns false if either 
	the direction does not represent a child, or capacity of the cell 
	has been reached.
	*/
	Boolean_tb Cell_fbToChild(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Modulo7_te const eDirection
	);

	/* Moves the cell to the parent, or returns false if there is none
	(i.e. at the root).
	*/
	Boolean_tb Cell_fbToParent(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)]
	);

	/* Steps over an edge in a given direction, setting the cell to the result.
	Returns the last direction travelled to get to the resulting cell,
	which may differ from the original direction if an underlap was traversed.
	For resolutions less than 4, movement may be restricted due to overlaps.
	Returns zero if no movement resulted.
	*/
	Modulo7_te Cell_feToAdjacent(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Modulo7_te eDirection
	);

	/* Returns the normalized direction in which to travel from the cell. */
	Modulo7_te Cell_feNormalizeDirection(
		REGISTER Cell_tzc const rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Modulo7_te eDirection
	);

	/* For each descendant of the given cell at the given resolution,
	calls fbAction({cell}, pData), and stops iteration if it returns false.
	Returns true if fbAction returned true in every case.
	Note that although the cell is not 'const', its value before and after the call is the same.
	If constness is required, make a non-const copy of the cell prior to calling this.
	*/
	Boolean_tb Cell_fbIterate(
		REGISTER Cell_tzc rzcCell[mReferenceConst(Cell_iMinimumCount)],
		REGISTER Modulo7_te const reChildOrder[mReferenceConst(7)],
		REGISTER char const cDirectionCount,
		REGISTER Boolean_tb (* const fbAction)(Cell_tzc const rzcCell[mReference(Cell_iMinimumCount)], void * pData),
		REGISTER void * const pData
	);

	/* Tests the code. */
	Boolean_tb Cell_fbTest(void);

#endif
