/******************************************************************************
notifier.cpp

begin		: 2006-04-08
copyright	: (C) 2006 by the PYXIS innovation inc.
web			: www.pyxisinnovation.com
******************************************************************************/

#define PYXLIB_SOURCE
#include "stdafx.h"
#include "pyxis/utility/notifier.h"

// pyxlib includes
#include "pyxis/utility/exception.h"
#include "pyxis/utility/trace.h"

// standard includes
#include <algorithm>

// local includes 
#include "pyxis/utility/tester.h"

//! Tester class
Tester< Notifier > gTester;

//! The name of the class
const std::string Observer::kstrDescription = "Generic Observer Class";

Notifier::~Notifier()
{
	// create a copy of the list of observers
	boost::recursive_mutex::scoped_lock lock(getMutex());
	const ObserverList lstObserversCopy = m_lstObservers;
	lock.unlock();

    // iterate list and detach all observers
	ObserverList::const_iterator itObserver;
    itObserver = lstObserversCopy.begin();
    while ( itObserver != lstObserversCopy.end() )
    {
		detach( *itObserver);
		++itObserver;
	}
}

/*!
Process the event from an observed class.

\sa updateObserverImpl

\param spEvent	The event generated by the observed class.
*/
void Observer::updateObserver(PYXPointer<NotifierEvent> spEvent)
{
	// perform the update
	updateObserverImpl(spEvent);
}

/*!
Copy the contents of the observer vector to the new object.

\param rhs	The object to construct a copy of.
*/
Notifier::Notifier(const Notifier& rhs)
{
	TRACE_NOTIFY(	"Constructing a copy of notifier '" << 
					rhs.getNotifierDescription() << "'."	);
	m_strName = rhs.m_strName;
	ObserverList::const_iterator itObservers = rhs.m_lstObservers.begin();
	for (; itObservers != rhs.m_lstObservers.end(); ++itObservers)
	{
		m_lstObservers.push_back(*itObservers);
	}
}

//! The name of the class
const std::string Notifier::kstrDescription = "Generic Notifier Class";

/*!
Attach an observer to this notifier.  An observer may not attach
to a single notifier more than one time.

\param pObserver	The class to notify of events.
*/
void Notifier::attach(Observer* pObserver)
{
	TRACE_NOTIFY(	"Attaching observer '" << pObserver->getObserverDescription() << 
					"' to notifier '" << getNotifierDescription() << "'."	);

	// get the lock
	boost::recursive_mutex::scoped_lock lock(m_notifierMutex);

    // verify the attach is not repeated
	if (std::find(	m_lstObservers.begin(), 
					m_lstObservers.end(), 
					pObserver) != m_lstObservers.end()	)
	{
		TRACE_ERROR("Multiple attach of same object.");
		assert(false && "Multiple attach of same object.");
		return;
    }
	m_lstObservers.push_back(pObserver);
}

/*!
Attach a delegate observer to this notifier.  An observer may not attach
to a single notifier more than one time.

\param callbackFn	The function to call when events fire.
*/
void Notifier::attach( DelegateObserver::Delegate callbackFn)
{
	DelegateObserver *observer = new DelegateObserver( callbackFn);

	boost::recursive_mutex::scoped_lock lock(m_notifierMutex);

	ObserverList::iterator itObservers = m_lstObservers.begin();
	for (; itObservers != m_lstObservers.end(); ++itObservers)
	{
		DelegateObserver *actualObserver = dynamic_cast<
			DelegateObserver *>( *itObservers);
		if ((actualObserver != 0) &&
			(*actualObserver == *observer))
		{
			delete observer;
			return;
		}		
	}

	attach( observer);
}

/*!
Remove an object from the list of observers of this notifier.

\param callbackFn	The delegate to remove from the notification list.
*/
void Notifier::detach( DelegateObserver::Delegate callbackFn)
{
	DelegateObserver signature( callbackFn);

	boost::recursive_mutex::scoped_lock lock(m_notifierMutex);
	ObserverList::iterator itObservers = m_lstObservers.begin();
	for (; itObservers != m_lstObservers.end(); ++itObservers)
	{
		DelegateObserver *actualObserver = dynamic_cast<
			DelegateObserver *>( *itObservers);
		if ((actualObserver != 0) &&
			(*actualObserver == signature))
		{
			detach( actualObserver);
			delete actualObserver;
			return;
		}		
	}
}

/*!
Remove an object from the list of observers of this notifier.

\param pObserver	The observer to remove from the notification list.
*/
void Notifier::detach(Observer* pObserver)
{
	// trace out the participating classes
	TRACE_NOTIFY(	"Detaching observer '" << pObserver->getObserverDescription() << 
					"' from notifier '" << getNotifierDescription() << "'."	);

	// get the lock
	boost::recursive_mutex::scoped_lock lock(m_notifierMutex);

	m_lstObservers.remove(pObserver);
}

/*!
Notify each observer (in attachment order) of a particular event. It is
the responsibility of any derived class to ensure thread safety in the
notifyImpl method.

\param spEvent	The event to notify the observers of.
*/
void Notifier::notify(PYXPointer<NotifierEvent> spEvent)	
{
	try
	{
		// Perform the appropriate implementation
		notifyImpl(spEvent);
	}
	catch (PYXException&)
	{
		TRACE_ERROR(	"PYXIS error occurred during notification from '" <<
						getNotifierDescription() << "'. Aborting any further notifications."	);
	}
	catch (...)
	{
		TRACE_ERROR(	"Unknown error occurred during notification from '" <<
						getNotifierDescription() << "'. Aborting any further notifications."	);
		// TODO: Print out std error output
	}
}

/*!
The default implementation takes a copy of the observer list as it
existed at the time of the notification and notifies each entry. Each entry is
verified that it is still associated with the notifier before the notification
call is made.

\param spEvent	The event to notify the observers of.
*/
void Notifier::notifyImpl(PYXPointer<NotifierEvent> spEvent)
{
	// create a copy of the list of observers
	boost::recursive_mutex::scoped_lock lock(getMutex());
	const ObserverList lstObserversCopy = m_lstObservers;
	lock.unlock();

    // iterate list and call all update methods of observers
	ObserverList::const_iterator itObserver;
    itObserver = lstObserversCopy.begin();

	// TODO: Investigate updating observers in parallel for performance.
    while ( itObserver != lstObserversCopy.end() )
    {
		// process the notify if still attached to the object
		lock.lock();
		if (	std::find(	m_lstObservers.begin(), 
							m_lstObservers.end(), 
							*itObserver) != m_lstObservers.end()	)
		{
			lock.unlock();
			TRACE_NOTIFY(	"Notify observer '" << 
							(*itObserver)->getObserverDescription() <<
							"' from '" << getNotifierDescription() << "'."	);
			(*itObserver)->updateObserver(spEvent);
		}
		else
		{
			lock.unlock();
		}
		++itObserver;
	}
}

/*!
Get the number of observers.

\return The number of observers.
*/
int Notifier::getObserverCount() const	
{
	// get the lock
	boost::recursive_mutex::scoped_lock lock(m_notifierMutex);

	TRACE_NOTIFY(	"Notifier '" << this->getNotifierDescription() << "' has '" <<
					static_cast<int>(m_lstObservers.size()) << "' observers."	);
	return static_cast<int>(m_lstObservers.size());
}


//! The name of the class
const std::string DelegateObserver::kstrDescription = "Delegate Observer Class";

namespace LocalTests{
	int callbackCount = 0;

	void Callback(PYXPointer<NotifierEvent> spEvent)
	{
		++callbackCount;
	}

	class MemberFunctionTestClass
	{
		int m_callbackCount;
	public:
		MemberFunctionTestClass()
		{
			m_callbackCount = 0;
		}
		  
		void Callback(PYXPointer<NotifierEvent> spEvent)
		{
			++m_callbackCount;
		}

		int get_callbackCount() const
		{
			return m_callbackCount;
		}
	};
}

void Notifier::test()
{
	Notifier n("Test Notifier");
	n.attach(LocalTests::Callback);
	n.attach(LocalTests::Callback);
	TEST_ASSERT(LocalTests::callbackCount == 0);
	n.notify(PYXPointer<NotifierEvent>());
	TEST_ASSERT(LocalTests::callbackCount == 1);

	LocalTests::MemberFunctionTestClass mfTest;
	TEST_ASSERT(mfTest.get_callbackCount() == 0);
	n.attach(&mfTest, &LocalTests::MemberFunctionTestClass::Callback);
	n.attach(&mfTest, &LocalTests::MemberFunctionTestClass::Callback);
	n.notify(PYXPointer<NotifierEvent>());
	TEST_ASSERT(mfTest.get_callbackCount() == 1);
	TEST_ASSERT(LocalTests::callbackCount == 2);
}