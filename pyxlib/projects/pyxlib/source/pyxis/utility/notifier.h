#ifndef PYXIS__UTILITY__NOTIFIER_H
#define PYXIS__UTILITY__NOTIFIER_H
/******************************************************************************
notifier.h

begin		: 2004-10-05
copyright	: derived from igo_exception.h (C) 2000 by iGO Technologies Inc.
web			: www.pyxisinnovation.com
******************************************************************************/

// pyxlib includes
#include "pyxlib.h"
#include "pyxis/utility/object.h"

// boost includes
#include <boost/thread/recursive_mutex.hpp>

// standard includes
#include <list>

// local forward declarations
class Notifier;

/*!
The base class for all events sent from the notifier to the observer.
*/
class PYXLIB_DECL NotifierEvent : public PYXObject
{
public:
	// nothing here at the moment, only in derived classes
	virtual ~NotifierEvent() {}
};

/*!
Observe and process relevent events from Notifier objects.

\sa Notifier
*/
//! Observes a notifier class and processes events.
class PYXLIB_DECL Observer
{
public:
	
	//! The name of the class.
	static const std::string kstrDescription;

	//! Default destructor.
	virtual ~Observer() {}

	/*! 
	Return the name of the observer class. If the method is not overridden
	the name 'Generic Observer Class' is returned. This functionality is
	used primarily for logging.

	\return The name of the observer class.
	*/
	//! Return the name of the class.
	virtual std::string getObserverDescription() const {return kstrDescription;}

protected:

	/*!
	Process the event from an observed class. Before this implementation
	method is called the observer is locked against access from other
	threads using a boost::recursive_mutex.

	\param spEvent	The event generated by the observed class.
	*/
	//! Process notification events from observed classes.
	virtual void updateObserverImpl(PYXPointer<NotifierEvent> spEvent) = 0;

	/*!
	Return the mutex for the observer class. This mutex can be used to provide
	exclusive access by one thread only during a portion of the update process.
	A mutex lock should only be applied when the full impact of the action is
	understood and investigated.

	\return the mutex for this observer instance.
	*/
	//! return the mutex for the observer class.
	boost::recursive_mutex& getMutex() {return m_observerMutex;}

private:

	//! Allow the notifiers to call the private updateObserver call
	friend class Notifier;

private:

	//! Process notification events from observed classes.
	void updateObserver(PYXPointer<NotifierEvent> spEvent);

private:

	//! Mutex to serialize concurrent access by multiple threads
	mutable boost::recursive_mutex m_observerMutex;
};

#ifndef SWIG
/*!
A DelegateObserver is a specialization of an Observer, which calls a
specific (callback) function instead of simply calling the Observer's
updateObserverImpl.  This allows global functions or static functions
to be called whenever a notifier fires.
*/
class PYXLIB_DECL DelegateObserver: public Observer
{
public:
	/*! typedef for a Delegate (call back function). */
	typedef void (*Delegate)(PYXPointer<NotifierEvent> spEvent);
	
	/*! Constructor.  Takes the function to be called on notification. */
	DelegateObserver( Delegate callbackFunction)
	{
		m_callback = callbackFunction;
	}

	//! The name of the class.
	static const std::string kstrDescription;

	//! Default destructor.
	virtual ~DelegateObserver() {}

	/*! 
	Return the name of the observer class. If the method is not overridden
	the name 'Generic DelegateObserver Class' is returned. This functionality is
	used primarily for logging.

	\return The name of the observer class.
	*/
	//! Return the name of the class.
	virtual std::string getObserverDescription() const {return "Delegate Observer";}

	/*! Helper function to find matching delegates. */
	bool operator==( const DelegateObserver &rhs) const
	{
		return (m_callback == rhs.m_callback);
	}

protected:

	/*! The member function to call within the object. */
	Delegate m_callback;

	/*!
	Process the event from an observed class. Before this implementation
	method is called the observer is locked against access from other
	threads using a boost::recursive_mutex.

	\param spEvent	The event generated by the observed class.
	*/
	//! Process notification events from observed classes.
	virtual void updateObserverImpl(PYXPointer<NotifierEvent> spEvent)
	{
		m_callback( spEvent);
	}
};
#endif /* SWIG */

/*!
A MemberDelegateObserver is a specialization of an Observer, which calls 
a specific (callback) member function instead of simply calling the 
Observer's updateObserverImpl.  This allows non-observers to connect to a 
notifier, and also allows a single class to respond differently to different
notifications (based on their source.)
*/

template <class T>
class MemberDelegateObserver: public Observer
{
public:

	//! Typedef of the delegate member function. 
	typedef void (T::*Delegate)(PYXPointer<NotifierEvent> spEvent);
	
	/*! Constructor.  Takes the object, plus its member function. */
	MemberDelegateObserver( T *object, Delegate callbackFunction)
	{
		assert(object != 0);
		m_object = object;
		m_callback = callbackFunction;
	}

	//! Default destructor.
	virtual ~MemberDelegateObserver() {}

	/*! 
	Return the name of the observer class. If the method is not overridden
	the name 'Generic DelegateObserver Class' is returned. This functionality is
	used primarily for logging.

	\return The name of the observer class.
	*/
	//! Return the name of the class.
	virtual std::string getObserverDescription() const {return "Member Delegate Observer";}

	//! Helper function to find matching delegates.
	bool operator==( const MemberDelegateObserver<T> &rhs) const
	{
		return (m_object == rhs.m_object) &&
			(m_callback == rhs.m_callback);
	}

protected:

	//! The object that will be used for the callback.  (This!) 
	T *m_object;

	//! The member function to call within the object. 
	Delegate m_callback;

	/*!
	Process the event from an observed class. Before this implementation
	method is called the observer is locked against access from other
	threads using a boost::recursive_mutex.

	\param spEvent	The event generated by the observed class.
	*/
	//! Process notification events from observed classes.
	virtual void updateObserverImpl(PYXPointer<NotifierEvent> spEvent)
	{
		((*m_object).*m_callback)( spEvent);
	}
};

/*!
The notifier class provides a mechanism for multiple objects to observe
The state of another object (the subject).   The subject will contain
a notifier object.  When an observer object wants to be aware of changes to
the subject it will call the attach method passing in a pointer to itself
(the observer).  When something interesting happens to the subject
the notify() method needs to be invoked.  The notify method will walk the
list of observers and invoke the update method of each passing a reference
to the subject.  The update() method of each observer will deal with this
notification in whatever manner is appropriate for that object (i.e., update
a display, recalculate some values, etc.)

Following is a rough set up steps required to set up notification.

1) Subject initializes a contained notifier object during its own construction.
The subject can simply expose the methods provided by the notifier object but
it would be preferable to override them.

2) An observer is given a reference to a subject (can be during construction or
later).

3) Observer indicates it should be notified when something interesting happens
to the subject by calling the attach() method of the notifier contained in the
subject.  The observer passes a pointer to itself when it calls attach().

4) When an interesting event occurs (i.e., the subjects state changes) the
notify() method is invoked.

5) When the update() method of an attached observer is invoked it should check
that the void pointer parameter is equivalent to the (or one of the) subjects
it is observing.

6) When an observer no longer wishes to observe a subject it should call the
subjects detach() method.
\sa Observer
*/
//! Notifies interested classes of events.
class PYXLIB_DECL Notifier
#ifdef INSTANCE_COUNTING
	: protected InstanceCounter
#endif
{
public:
	//! Unit test
	static void test();

	//! Default 'do nothing' constructor.
	explicit Notifier(const std::string strName = kstrDescription) : 
	m_strName(strName) {;}

	//! Destructor.
	virtual ~Notifier(); 

	//! Copy constructor for notifier objects.
	Notifier(const Notifier& rhs);

	//! Attaches to the object to receive notifications.
	void attach(Observer* pObserver);

	//! Detaches an observer from the object (a subject)
	void detach(Observer* pObserver);

	//! Set the name of the notifier
	void setNotifierName(const std::string strName) {m_strName = strName;}

#ifndef SWIG
	//! Attaches a delegate to the object to receive notifications.
	void attach( DelegateObserver::Delegate callbackFn);

	//! Detaches a delegate from the object.
	void detach( DelegateObserver::Delegate callbackFn);

	//! Attaches a member-delegate to the object to receive notifications.
	template <class T>
	void attach( T *object, typename MemberDelegateObserver<T>::Delegate callbackFn)
	{
		MemberDelegateObserver<T> signature( object, callbackFn);
		
		ObserverList::iterator itObservers = m_lstObservers.begin();
		for (; itObservers != m_lstObservers.end(); ++itObservers)
		{
			MemberDelegateObserver<T> *actualObserver = dynamic_cast<
				MemberDelegateObserver<T> *>( *itObservers);
			if ((actualObserver != 0) &&
				(*actualObserver == signature))
			{
				return;
			}
		}

		attach( new MemberDelegateObserver<T>( object, callbackFn));
	}

	//! Detaches a member-delegate from the object.
	template <class T>
	void detach( T *object, typename MemberDelegateObserver<T>::Delegate callbackFn)
	{
		MemberDelegateObserver<T> signature( object, callbackFn);

		ObserverList::iterator itObservers = m_lstObservers.begin();
		for (; itObservers != m_lstObservers.end(); ++itObservers)
		{
			MemberDelegateObserver<T> *actualObserver = dynamic_cast<
				MemberDelegateObserver<T> *>( *itObservers);
			if ((actualObserver != 0) &&
				(*actualObserver == signature))
			{
				detach( actualObserver);
				delete actualObserver;
				return;
			}		
		}
		// If we got here, then we didn't find the observer.  Log a message?
	}
#endif // SWIG

	//! Direct the notification class to inform observers of the event.
	void notify(PYXPointer<NotifierEvent> spEvent);

	//! Get the number of observers.
	int getObserverCount() const;

	/*! 
	Return the name of the notifier class. The name is the descriptive name
	that the notifier class was constructed with. If no name was specified
	a generic notifier name is given.

	\return The name of the notifier class.
	*/
	//! Return the name of the notification class.
	std::string getNotifierDescription() const {return m_strName;}

protected:

	//! List of observers to be notified of changes.
	typedef std::list<Observer*> ObserverList;

	//! Return the observers.
	ObserverList* getNotificationList() {return &m_lstObservers;}

	//! Perform the internal notification algorithm.
	virtual void notifyImpl(PYXPointer<NotifierEvent> spEvent);

	/*!
	Return the mutex for the notifier class. This mutex can be used to provide
	exclusive access by one thread only during a portion of the notify process.
	A mutex lock should only be applied when the full impact of the action is
	understood and investigated.

	\return the mutex for this notifier instance.
	*/
	//! return the mutex for the notifier class.
	boost::recursive_mutex& getMutex() {return m_notifierMutex;}

private:

	//! The name of the class.
	static const std::string kstrDescription;

	//! Mutex to serialize concurrent access by multiple threads
	mutable boost::recursive_mutex m_notifierMutex;

	//! Observers to be notified of changes.
	ObserverList m_lstObservers;

	//! The name of the notifier (used for logging).
	std::string m_strName;
};

/*
If we are defining the SWIG interface, we need to emulate multiple 
inheritance.  Classes that are multiply derived from Notifier will 
include the SWIG_NOTIFIER macro within their class definition.

What we're really doing is exposing all of the Notifier interface.

Note that this macro should be placed at the end of your class, or
in a public section.
*/
#define SWIG_NOTIFIER \
    public: \
	    Notifier *getNotifier() { return static_cast<Notifier *>( this);} \
		using Notifier::attach; \
		using Notifier::detach; \
		using Notifier::getObserverCount; \
		using Notifier::notify; 

/*! Define a class for integration/unit testing from .Net */
class UnitTests_NotifierBase{};
class UnitTests_NotifierDerived: public UnitTests_NotifierBase, public Notifier
{
	SWIG_NOTIFIER;
};

#endif // guard